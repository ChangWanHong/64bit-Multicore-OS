# 내 PC를 부팅하자

## 부팅과 부트로더
모든 OS들은 512바이트 크기의 작은 코드에서 시작한다.
512바이트의 작은 코드는 **부트로더(Boot loader)라고 불리며, OS의 나머지 코드를 메모리에 복사해 실행한다.

### 부팅과 BIOS
**부팅(Booting)**은 PC가 켜진 후에 OS가 실행되기 전까지 수행되는 일련의 작업과정을 의미한다.
부팅 과정에서 수행하는 작업에는 프로세서 초기화(멀티코어 관련 처리 포함), 메모리와 외부 디바이스 검사 및 초기화, 부트로더를 메모리에 복사하고 OS를 시작하는 과정 등이 포함된다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch4_img1.jpg)

MINT64 OS의 부팅과정이다.
PC환경에서는 부팅 과정 중 하드웨어와 관련된 작업을 BIOS(Basic Input/Output System)가 담당하며, BIOS에서 수행하는 각종 테스트나 초기화를 POST(Power On Self Test)라고 부른다.

**BIOS**는 메인보드에 포함된 펨웨어(Firmware)의 일종으로, 이름 그대로 입출력을 담당하는 작은 프로그램이다.
보통 PC 메인보드에 롬(ROM)이나 플래시 메모리로 존재하며, 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행하는 코드이다.
BIOS는 부팅 옵션 설정이나 시스템 전반적인 설정 값(Configuration)을 관리하는 역할도 겸하며, 설정값으로 시스템을 초기화하여 OS를 실행할 수 있는 환경을 만든다.
BIOS에서 제공하는 기능은 인터럽트를 통해 사용할 수 없으며, MS-DOS 같은 과거의 16비트 OS는 BIOS의 기능에 많이 의존했다.
MINT64 OS도 OS 이미지를 메모리에 복사하고 GUI 모드로 변환할 때 BIOS의 기능을 사용한다.

BIOS는 부팅 과정에서 시스템 초기화 외에 수많은 작업을 하지만, 그중에서 우리에게 가장 중요한 것은 부트로더 이미지를 메모리로 복사하는 단계이다.
부트로더는 **부트스트랩(Bootstrap) 코드**라고도 불리며 우리가 BIOS에서 처음으로 제어를 넘겨받는 부분이다.
부트로더는 플로피 디스크나 하드 디스크 등 저장 매체의 가장 앞부분에 존재한다.
PC는 디스크나 플래시 메모리 등 다양한 장치로 부팅할 수 있으므로 BIOS는 POST가 완료된 후 여러 장치를 검사하여 앞부분에 부트로더가 있는지 확인한다.
부트로더가 존재한다면 코드를 0x7C00 어드레스에 복사한 후 프로세서가 0x7C00 어드레스부터 코드를 수행하도록 한다.
부팅가능한 모든 장치를 검사했는데도 부트로더를 찾을 수 없다면 BIOS 'Operating System Not Found'와 같은 메시지를 출력하고 작업을 중단한다.

부트로더가 디스크에서 메모리로 복사되어 실행되었다는것은 BIOS에 의해 PC가 정상적으로 구동되었다는 것을 의미한다.
다시 말하면 우리가 만든 OS를 메모리에 올려서 실행할 준비가 된것이다.

### 부트 로더의 역할과 구성
부트로더는 플로피 디스크나 하드 디스크 같은 외부 저장 매체에 있으며, 저장 매체에서 가장 첫번째 섹터 MBR(Master Boot Record)에 있는 작은 프로그램이다.
섹터(Sector)는 디스크를 구성하는 데이터의 단위로, 섹터 하나는 512바이트로 구성된다.
부트로더의 가장 큰 역할은 OS 실행에 필요한 환경을 설정하고, OS 이미지를 메모리에 복사하는 일이다.
부트로더는 BIOS가 가장 먼저 실행하는 중요한 프로그램이므로 기능이 다양하다고 생각할지도 모른다.
하지만, 부트로더는 크기가 512바이트로 정해져 있다.
즉 공간 제약이 있어서 처리할 수 있는 기능이 한정된다.
이렇게 작은 공간에 다양한 기능을 우겨 넣는 일은 무리이므로 대부분 부트로더는 OS 이미지를 메모리로 복사하고 제어를 넘겨주는 정형화된 작업을 수행한다.
4장과 5장에서 만들 부트로더 역시 OS 이미지를 디스크에서 메모리로 복사하는 역할만 수행한다.

부트 로더의 크기 문제는 부트로더의 기능을 최소화해서 해결했다.
그렇다면 BIOS에 첫번째 섹터가 부트로더란 것을 어떻게 알려줄까? 그리고 BIOS는 디스크에서 읽은 첫 번째 섹터가 정상적인 부트로더인지 어떻게 판단할까?

디스크를 부팅할 용도로 사용하지 않는다면, 첫번째 섹터는 부트로더가 아닌 일반 데이터가 저장된다.
만약 BIOS가 실수로 데이터를 메모리에 올려 실행한다면 모니터에 번쩍하는 섬광과 함께 PC가 리부팅된다.
이러한 사태를 방지하려면 BIOS는 첫번째 섹터에 있는 데이터가 부트로더인지 확인해야한다.

이를 위해 BIOS는 읽어들인 512바이트 중에 가장 마지막 2바이트의 값이 0x55, 0xAA인지 검사해서 부트로더인지 확인해야한다.
읽은 데이터가 0x55, 0xAA로 끝나지 않는다면 데이터로 인식하고 부팅 과정을 더 진행하지 않는다.
첫번째 섹터에 부트로더가 아닌 데이터를 저장할 생각이라면 마지막 2바이트는 0x55, 0xAA가 아닌 다른 값으로 써야한다.

## 부트로더 제작을 위한 준비
이제부터 만들 OS의 이름을 **MINT64 OS**라고 지칭하겠다.
본격적인 프로그래밍에 앞서, MINT64 OS 프로젝트를 생성한다.
책에서는 이클립스로 진행하지만, 편의를 위해 Jetbrains의 Clion으로 진행하겠다.

### 프로젝트 생성
Clion에서 MINT64라는 프로젝트를 생성한다.
특별히 설명할 내용은 없으므로 건너 뛰도록 하겠다.
[MINT64]()보고 따라오면 된다.

### MINT64 OS의 디렉터리 구조 생성
MINT64 OS는 리얼모드, 보호모드, IA-32e모드용 코드를 나눠서 관리한다.
이러한 파일을 디렉터리 하나로 관리하는 것은 매우 비효율적이므로 디렉터리 구조를 다래 그림과 같이 항목별로 나누었다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch4_img2.jpg)

부트로더 디렉터리와 대부분 유틸리티 디렉터리는 다른 디렉터리와 달리 소스파일 디렉터리와 임시 파일 디렉터리를 구분하지 않는다.
부트로더는 어셈블리어 파일 하나로 이루어진 작은 프로그램이므로 굳이 디렉터리를 구분하지 않아도 관리가 가능하다.
하지만, 보호모드 커널, IA-32e 커널, 각 응용프로그램은 여러 파일로 복잡하게 구성되므로 혼잡함을 줄이려고 임시 파일 디렉터리를 별로도 생성했다.

아래 이미지는 Clion project explorer 화면이다.
이렇게 디렉터리를 설정해주면 된다.
