# C언어로 커널을 작성하자

## 실행 가능한 C 코드 커널 생성 방법
지금까지 작성한 소스는 전부다 단일 파일로 구성되고, 각 파일은 NASM 컴파일러를 통해 Binary 형태로 생성되었다.
현재 보모 모드 커널 역시 엔트리 포인트 소스파일 EntryPoint.s 하나로 구성되어 있으며, 512 바이트로 정렬되어 OS 이미지 파일에 결합되는 구조를 하고 있다.

이번 장에서는 C 소스 파일을 추가하고, 이를 빌드하여 보호 모드 커널 이미지에 통합하는 것이다.
C언어로 작성한 커널을 보호 모드 엔트리 포인트의 뒷부분에 연결하고 엔트리 포인트에서는 C커널의 시작 부분으로 이동하는것이 전부이다.

C코드는 어셈블리어 코드와 달리 컴파일과 링크 과정을 거쳐서 최종 결과물이 생성된다.
컴파일 과정은 소스 파일을 중간 단계인 오브젝트 파일(Object file)로 변환하는 과정을 소스 파일을 해석하여 코드 영역과 데이터 영역으로 나누고, 이러한 메모리 영역에 대한 정보를 생성하는 단계이다.
링크 단계는 오브젝트 파일들의 정보를 취합하여 실행 파일에 통합하며, 필요한 라이브러리 등을 연결해주는 역하릉 하는 단계이다.
아래 그림은 이러한 빌드 과정을 나타낸 것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch7_img1.jpg)

### 빌드 조건과 제약 사항
엔트리 포인트가 C 코드를 실행하려면 적어도 아래의 세 가지 제약 조건은 만족해야한다.

**1. C 라이브러리를 사용하지 않도록 빌드해야한다.**
부팅된 후 보호 모드 커널이 실행되면 C 라이브러리가 없으므로 라이브러리에 포함된 함수를 호출할 수 없다.
만약 커널 코드에서 어플리케이션 소스처럼 `printf()` 함수를 사용한다면, C 라이브럴리를 동적링크(Dynamic Link)또는 정적 링크(Static Link)하게 된다.
하지만 커널은 자신을 실행하기 위한 최소한의 환경만 설정하므로 라이브러리의 함수를 실행할 수 없다.

**2. 0x10200 위치에서 실행하도록 빌드해야한다.**
0x10000의 위치는 6장에서 작성한 섹터크기의 보호 모드 엔트리 포인트가 있으므로, 결합된 C코드는 512바이트 이후인 0x10200 위치부터 로딩된다.
따라서 C로 작성한 커널 부분은 빌드할때 0x10200 위치에서 실행되는 것을 전제로 해야하며, 해당 위치의 코드는 C 코드 중에 가장 먼저 실행되어야 하는 함수(엔트리 포인트)가 위치해야한다.
커널이 실행되는 어드레스가 중요한 이유는 선형 주소를 참조하게 생성된 코드나 데이터 때문이다.
C언어에서 전역 변수의 어드레스나 함수의 어드레스르 참조하는 경우, 실제로 존재하는 선형 주소로 변환된다.
따라서 메모리에 로딩되는 어드레스가 변한다면, 이러한 값들 역시 변경해줘야 정상적으로 작동한다.
아래와 같은 C코드가 있을때, 0x0000에서 로딩되어 실행되는 경우와 0x10200에서 로딩되어 실행되는 경우의 어셈블리어 코드는 아래와 같다. (g_iIndex 변수는 메모리 어드레스의 가장 앞쪽에 위치한다고 가정)

```   C
/**
 * C 코드
 */
/* 생략 */

int g_iIndex = 0;

void AddIndex() {
  g_iIndex++;
}
```

``` asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0x0000에 로딩된 어셈블리어 코드
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ~ 생략 ~

g_iIndex: DD  0x00000000    ; g_iIndex 변수는 로딩된 메모리 어드레스 처음에 위치한다고 가정

AddIndex:
  ; ~ 생략 ~
  
  mov eax, dword [ 0x0000 ] ; g_iIndex 변수의 어드레스에 접근하여 값을 EAX에 저장
  add eax, 1
  mov dword [ 0x0000 ], eax ; 1 증가도니 값을 g_iIndex 변수에 접근하여 다시 저장
  
  ; ~ 생략 ~
```

``` asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0x10200에 로딩된 어셈블리어 코드
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ~ 생략 ~

g_iIndex: DD  0x00000000    ; g_iIndex 변수는 로딩된 메모리 어드레스 처음에 위치한다고 가정

AddIndex:
  ; ~ 생략 ~
  
  mov eax, dword [ 0x10200 ] ; g_iIndex 변수의 어드레스에 접근하여 값을 EAX에 저장
  add eax, 1
  mov dword [ 0x10200 ], eax ; 1 증가도니 값을 g_iIndex 변수에 접근하여 다시 저장
  
  ; ~ 생략 ~
```
위 코드를 보면 메모리에 로딩되는 어드레스에 따라 전역 변수의 어드레스에 접근하는 부분이 변한다는 것을 알 수 있다.
이러한 이유로 커널이 0x10200의 어드레스에서 실행되게 빌드하는 것이 필요하다.

**3. 코드나 데이터 외에 기타 정보를 포함하지 않는 순수한 바이너리 파일 형태여야한다.**
일반적으로 GCC를 통해 실행파일을 생성하면 **ELF** 파일 포맷이나 PE파일 포맷과 같이 특정 OS에서 실행할 수 있는 포맷으로 생성된다.
이러한 파일 포맷들은 실행하는데 필요한 코드와 데이터 정보 이외의 불필요한 정보를 포함하고 있다.
해당 파일 포맷을 그대로 사용하게되면 엔트리 포인트에서 파일 포맷을 해석하여 해당 정보에 따라 처리하는 기능이 포함되어야 하므로 코드가 복잡해진다.
만일 부트 로더나 보호 모드 엔트리포인트처럼 코드와 데이터만 포함된 바이너리 파일 형태를 사용한다면, 엔트리 포인트에서 해당 어드레스로 점프(jmp)하는 것만으로 C언어를 실행할 수 있다.

### 소스 파일 컴파일 - 라이브러리 사용하지 않는 오브젝트 파일 생성 방법
C코드를 컴파일하여 오브젝트 파일을 생성하는 방법은 아주 간단하다.
GCC 옵션으로 `-c`만 추가해주면 된다.

라이브러리를 사용하지 않고 홀로 동작할 수 있는 형태로 빌드해야한다.
`-ffreestanding`이라는 GCC 컴파일 옵션을 사용해야한다.

```
gcc -c -m32 -ffreestanding Main.c
```

`-m32` 옵션은 GCC가 32비트 코드 생성하도록 설정하는것이다.
일반적으로 GCC는 기본으로 64비트 코드를 생성한다.

### 오브젝트 파일 링크 - 라이브러리를 사용하지 않고 특정 어드레스에서 실행 가능한 커널 이미지 파일 생성 방법
오브젝트 파일을 링크하여 실행 파일을 만드는 방법은 소스 파일을 컴파일 하는 방법보다 까다롭다.
실행 파일을 구성하는 섹션의 배치와 로딩될 어드레스, 코드 내에서 가장 먼저 실행될 코드인 엔트리 포인트를 지정해줘야 하기 때문이다.
특히 섹션을 배치하는 작업은 오브젝트 파일이나 실행파일 구조와 관련이 있으므로 다른 작업보다 좀 더 까다로울 수 있다.
하지만, 섹션을 배치하는 방식과 크기 정렬 방식에 따라서 OS 메모리 구조와 크기가 달라지므로, 한번 아래 내용을 읽고 넘어가길을 권장한다.

섹션 배치를 다시 하는 이유는 실행 파일이 링크될때 코드나 데이터 이외의 디버깅 관련 정보와 심볼(Symbol, 함수나 변수의 이름) 정보가 포함되기 때문이다.
이러한 정보는 커널을 실행할때 불필요하므로, 최종 바이너리 파일을 생성할 때 이를 제거하려고 섹션을 재배치하는것이다.
섹션을 재배치하여 코드와 데이터를 실행 파일 앞쪽으로 이동시키면 손쉽게 나머지 부분을 제거할 수 있다.

### 섹션 배치와 링커 스크립트, 라이브러리를 사용하지 않는 링크
