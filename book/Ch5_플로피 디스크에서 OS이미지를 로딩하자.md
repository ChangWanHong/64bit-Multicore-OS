# 플로피 디스크에서 OS이미지를 로딩하자

## BIOS 서비스와 소프트웨어 인터럽트
BIOS는 키보드/마우스에서 디스크나 프린터까지 거의 모든 PC 주변기기를 제어하는 기능을 제공한다.
16비트 OS를 개발한다고하면 BIOS의 기능만 활용해도 OS를 개발할 수 있다.

BIOS는 우리가 일반적으로 많이 쓰는 라이브러리(Library) 파일과 달리 자신의 기능을 특별한 방법으로 외부에 제공한다.
함수의 어드레스를 인터럽트 벡터 테이블(Interrupt Vector Table)에 넣어두고, 소프트웨어 인터럽트(SWI, Software Interrupt)를 호출하는 방법을 사용한다.
인터럽트 벡터 테이블은 메모리 어드레스 0에 있는 테이블로 특정 번호의 인터럽트가 발생했을때 인터럽트를 처리하는 함수(인터럽트 핸들러, Interrupt Handler) 검색에 사용한다.
테이블의 각 항목은 인덱스에 해당하는 인터럽트가 발생했을 때 처리하는 함수 어드레스가 저장되어있으며, 각 항목은 크기가 4바이트이다.
또한 인터럽트는 최대 256개 까지 설정할 수 잇으므로 리얼 모드의 인터럽트 벡터 크기는 최대 256 * 4 = 1024바이트가 된다.
아래 표는 리얼모드에서 사용하는 인터럽트 벡터 테이블의 내용이다.
항목이 많아서 중요한 부분만 발췌했다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img1.jpg)

BIOS가 제공하는 디스크 서비스를 사용하려면 위에 나와있듯이 0x13 인터럽트를 발생시켜야한다.
이는 우리가 임의로 인터럽트를 발생시킬 수 잇어야 한다는것을 의미하며, 이때 소프트웨어 인터럽트 명령을 사용한다.
SWI는 CPU에 가상으로 특정 인터럽트가 발생했다고 알리는 명령어로 int 0x13 형태로 사용한다.
만든 함수의 어드레스를 인터럽트 벡터 테이블에 넣어뒀다면 int 명령으로 언제든지 해당 함수로 이동할 수 있다.

BIOS 서비스는 SWI를 통해 호출할 수 있지만 BIOS도 만능은 아니어서 작업에 관련된 파라미터를 넘겨줘야한다.
파라미터는 레지스터를 이용해서 넘겨준다.
BIOS의 기능을 사용할 때는 AX, BX, CX, DX 레지스터와 ES 세그먼트 레지스터를 사용해서 파라미터를 넘겨주며 결과값도 레지스터를 통해 넘겨받는다.
물론 BIOS  서비스 마다 요구하는 파라미터의 수가 다르므로 서비스를 호출할 때 파라미터로 정의된 레지스터를 꼭 확인해야한다.
디스크 관련 서비스 주엥 리셋과 섹터 읽기 기능을 예로 들면 아래 표와 같다.
보면 AX레지스터는 기능 선택과 처리한 결과값을 받을 때 공통으로 사용되는 것을 알 수 잇따.
이는 BIOS의 디스크관련 서비스 뿐만 아니라 다른 서비스에도 마찬가지로 적용되는 규칙이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img2.jpg)
