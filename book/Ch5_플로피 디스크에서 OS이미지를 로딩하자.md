# 플로피 디스크에서 OS이미지를 로딩하자

## BIOS 서비스와 소프트웨어 인터럽트
BIOS는 키보드/마우스에서 디스크나 프린터까지 거의 모든 PC 주변기기를 제어하는 기능을 제공한다.
16비트 OS를 개발한다고하면 BIOS의 기능만 활용해도 OS를 개발할 수 있다.

BIOS는 우리가 일반적으로 많이 쓰는 라이브러리(Library) 파일과 달리 자신의 기능을 특별한 방법으로 외부에 제공한다.
함수의 어드레스를 인터럽트 벡터 테이블(Interrupt Vector Table)에 넣어두고, 소프트웨어 인터럽트(SWI, Software Interrupt)를 호출하는 방법을 사용한다.
인터럽트 벡터 테이블은 메모리 어드레스 0에 있는 테이블로 특정 번호의 인터럽트가 발생했을때 인터럽트를 처리하는 함수(인터럽트 핸들러, Interrupt Handler) 검색에 사용한다.
테이블의 각 항목은 인덱스에 해당하는 인터럽트가 발생했을 때 처리하는 함수 어드레스가 저장되어있으며, 각 항목은 크기가 4바이트이다.
또한 인터럽트는 최대 256개 까지 설정할 수 잇으므로 리얼 모드의 인터럽트 벡터 크기는 최대 256 * 4 = 1024바이트가 된다.
아래 표는 리얼모드에서 사용하는 인터럽트 벡터 테이블의 내용이다.
항목이 많아서 중요한 부분만 발췌했다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img1.jpg)

BIOS가 제공하는 디스크 서비스를 사용하려면 위에 나와있듯이 0x13 인터럽트를 발생시켜야한다.
이는 우리가 임의로 인터럽트를 발생시킬 수 잇어야 한다는것을 의미하며, 이때 소프트웨어 인터럽트 명령을 사용한다.
SWI는 CPU에 가상으로 특정 인터럽트가 발생했다고 알리는 명령어로 int 0x13 형태로 사용한다.
만든 함수의 어드레스를 인터럽트 벡터 테이블에 넣어뒀다면 int 명령으로 언제든지 해당 함수로 이동할 수 있다.

BIOS 서비스는 SWI를 통해 호출할 수 있지만 BIOS도 만능은 아니어서 작업에 관련된 파라미터를 넘겨줘야한다.
파라미터는 레지스터를 이용해서 넘겨준다.
BIOS의 기능을 사용할 때는 AX, BX, CX, DX 레지스터와 ES 세그먼트 레지스터를 사용해서 파라미터를 넘겨주며 결과값도 레지스터를 통해 넘겨받는다.
물론 BIOS  서비스 마다 요구하는 파라미터의 수가 다르므로 서비스를 호출할 때 파라미터로 정의된 레지스터를 꼭 확인해야한다.
디스크 관련 서비스 주엥 리셋과 섹터 읽기 기능을 예로 들면 아래 표와 같다.
보면 AX레지스터는 기능 선택과 처리한 결과값을 받을 때 공통으로 사용되는 것을 알 수 잇따.
이는 BIOS의 디스크관련 서비스 뿐만 아니라 다른 서비스에도 마찬가지로 적용되는 규칙이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img2.jpg)


## OS 이미지 로딩 기능 구현
### 디스크 읽기 기능 구현
MINT64 OS의 이미지는 크게 부트로더, 보호 모드 커널, IA-32e 모드 커널로 구성되며, 각 부분은 섹터 단위로 정렬해서 하나의 부팅 이미지 파일로 합친다.
따라서 디스크의 두번째 섹터부터 읽어서 특정 메모리 어드레스에 순서대로 복사하면 이미지 로딩은 끝이다.
MINT64 OS는 OS 이미지 를 0x10000(64Kbyte)에 로딩해서 실행한다.
하지만, OS 이미지를 반드시 0x10000 위치에 로딩해야 실행되는것은 아니다.
부트로더 이후(0x07C00)에 연속해서 복사해도 OS실행에 문제는 없다.
MINT 64 OS는 0x10000하위 영역을 다른 용도로 사용하기에 남겨둔 것이다.

플로피 디스크의 첫 번째 섹터는 부트로더로 BIOS가 메모리에 로딩한다.
따라서 플로피 디스크의 두 번째 섹터부터 OS 이미지 크기만큼 읽어서 메모리에 복사하면 된다.
플로피 디스크의 섹터는 섹터 -> 헤드 -> 트랙의 순서로 배열되어 잇으므로 이 순서만 지킨다면 큰 문제 없이 로딩할 수 잇다.
섹터 배열 순서를 고려하여 작성한 C코드는 아래와 같다.
섹터 번호를 순서대로 증가시키며 읽다가 마지막 섹터에서 헤드와 트랙 번호를 증가시키는 것이 핵심 포인트이다.

``` C
int main(int argc, char *argv[]) {
    int iTotalSectorCount = 1024;
    int iSectorNumber = 2;
    int iHeadNumber = 0;
    int iTrackNumber = 0;
    // 실제 이미지를 복사할 어드레스(물리 주소)
    char *pcTargetAddress = (char *) 0x10000;

    while (1) {
        // 전체 섹터 수를 하나씩 감소시키면서 0이 될 때까지 섹터를 복사
        if (iTotalSectorCount == 0)
            break;
        iTotalSectorCount--;

        // 1 섹터를 읽어들여서 메모리 어드레스에 복사
        // BIOSReadOneSector: BIOS의 세거 읽기 기능을 호출하는 임의의 함수
        if (BIOSReadOneSector(iSectorNumber, iHeadNumber, iTrackNumber, pcTargetAddress) == ERROR)
            HandleDiskError();

        // 1 섹터는 512(0x200) 바이트이므로 복사한 수만큼 어드레스 증가 
        pcTargetAddress = pcTargetAddress + 0x200;

        // 섹터 -> 헤드 -> 트랙 순으로 번호 증가
        iSectorNumber++;
        if (iSectorNumber < 19)
            continue;

        // 헤드의 번호는 0과 1이 반복되므로 이를 편리하게 처리하기위해 XOR 연산을 사용
        // iHeadNumber = (iHeadNumber == 0x00) ? 0x00 : 0x01; 과 같은 의미
        iHeadNumber = iHeadNumber ^ 0x01;
        iSectorNumber = 1;

        if (iHeadNumber != 0)
            continue;

        iTrackNumber++;
    }
    return 0;
}

int HandleDiskError() {
    printf("DISK Error!!");
    while (1);
}
```

위의 C언어 코드를 참고하여 어셈블리어 소스 코드를 작성하면 아래와 같다.

``` asm
TOTALSECTORCOUNT:   dw  1024    ; 부트로더를 제외한 MINT64 OS이미지의 크기
                                ; 최대 1152 섹터(0x90000byte)까지 가능
SECTORNUMBER:       db  0x02    ; OS 이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER:         db  0x00    ; OS 이미지가 시작하는 헤드 번호를 저장하는 영역
TRACKNUMBER:        db  0x00    ; OS 이미지가 시작하는 트랙 번호를 저장하는 영역

    ;디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x1000으로 설정
    mov si, 0x1000      ; OS 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환
    mov es, si          ; ES 세그먼트에 값 설정
    mov bx, 0x0000      ; BX 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

    mov di, word [ TOTALSECTORCOUNT ]   ; 복사할 OS 이미지의 섹터 수를 DI 레지스터에 설정

READDATA:               ; 디스크를 읽는 코드의 시작
    ; 모든 섹터를 다 읽었는지 확인
    cmp di, 0           ; 복사할 OS의 이미지의 섹터 수를 0과 비교
    je READEND          ; 복사할 섹터 수가 0이라면 다 복사했으므로 READEND로 이동
    sub di, 0x01        ; 복사할 섹터 수를 1 감소

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; BIOS Read Function 호출
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov ah, 0x02                    ; BIOS 서비스 번호 2(Read Sector)
    mov al, 0x1                     ; 읽을 섹터 수는 1
    mov ch, byte [ TRACKNUMBER ]    ; 읽을 트랙 번호 설정
    mov cl, byte [ SECTORNUMBER ]   ; 읽을 섹터 번호 설정
    mov dh, byte [ HEADNUMBER ]     ; 읽을 헤드 번호 설정
    mov dl, 0x00                    ; 읽을 드라이브 번호(0=Floppy) 설정
    int 0x13                        ; 인터럽트 서비스 수행
    jc HANDLEDISKERROR              ; 에러가 발생했다면 HANDLEDISKERROR로 이동

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 복사할 어드레스와 트랙, 헤드 섹터 어드레스 계산
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    add si, 0x0020      ; 512(0x200)바이트 만큼 읽었으므로 이를 세그먼트 레지스터 값으로 변환
    mov es, si          ; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터만큼 증가

    ; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
    ; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행
    mov al, byte [ SECTORNUMBER ]   ; 섹터 번호를 AL레지스터에 설정
    add al, 0x01                    ; 섹터 번호를 1 증가
    mov byte [ SECTORNUMBER ], al   ; 증가시킨 섹터 번호를 SECTORNUMBER에 다시 설정
    cmp al, 19                      ; 증가시킨 섹터 번호를 19와 비교
    jl READDATA                     ; 섹터 번호가 19미만이라면 READDATA로 이동
    
    ; 마지막 섹터까지 읽었으면(섹터 번호가 19이면) 헤드를 토글(0->1, 1->0)하고, 섹터 번호를 1로 설정
    xor byte [ HEADNUMBER ], 0x01   ; 헤드 번호를 0x01과 XOR하여 토글(0->1, 1->0)
    mov byte [ SECTORNUMBER ], 0x01 ; 섹터 번호를 다시 1 로 설정
    
    ; 만약 헤드가 1->0으로 바뀌었으면 양쪽 헤드를 모두 읽은것이므로 아래로 이동하여 트랙 번호를 1 증가
    cmp byte [ HEADNUMBER ], 0x00   ; 헤드 번호를 0x00과 비교
    jne READDATA                    ; 헤드 번호가 0이 아니면 READDATA로 이동
    
    ; 트랙을 1 증가시킨 후, 다시 섹터 읽기로 이동
    add byte [ TRACKNUMBER ] , 0x01 ; 트랙 번호를 1 증가
    jmp READDATA                    ; READDATA로 이동
READEND:

HANDLEDISKERROR:    ; 에러를 처리하는 코드
    ; 생략
```

위의 어셈블리어 소스 코드와 디스크 리셋 기능만 부트로더에 추가하면 로딩할 준비가 끝난다.
그런데 기능은 구현했지만 화면에 출력하는 코드가 없어서 진행 상황이나 완료 유무를 확인하기 어렵다.
이번에는 화면에 진행 상태를 출력하도록 코드를 추가해보겠다

앞에서 환영 메시지를 출력하는 코드를 구현했다.
하지만 함수 형태로 구현하지 않아서 원하는 곳에서 호출할 수 없다.
무네즌 코드 구조뿐만 아니라 함수 호출에 필요한 핵심 자료구조또한 빠져있다는것이다.
이를 보완하여 함수 호출이 가능한 구조로 만들어 보겠다.

### 스택 초기화와 함수구현
x86 프로세서에서 함수를 사용하려면 스택(Stack)이 꼭 필요하다.
스택은 아래와 같이 데이터를 삽입하는 포인트와 제거하는 포인트가 같아서, 마지막에 들어간 데이터가 가장 먼저 나오는 형태의 자료구조(Last in, First out)이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img3.jpg)

x86 프로세서에서는 함수를 호출한 코드의 다음 어드레스, 즉 되돌아갈 어드레스(이하 복귀 어드레스, Return Address)를 저장하는 용도로 스택을 사용한다.
함수를 호출하면 프로세서가 자동으로 되돌아올 어드레스를 스택에 저장하며, 호출된 함수에서 되돌아감(ret)을 요청하면 자동으로 스택에서 어드레스를 꺼내 호출한 다음 어드레스로 이동하는 것이다.
스택은 복귀 어드레스를 저장하는 역할뿐만 아니라 함수의 파라미터를 저장하는 역할도 겸한다.
호출하는 쪽(Caller)과 호출되는 쪽 (Callee)은 정해진 규칙에 따랄 파라미터를 스택에 저장함으로서 협엄할 수 있다.

함수 호출을 위해 가장 먼저 해야할 일은 스택 생성이다.
x86프로세서는 스택관련 레지스터가 세가지 있다.
스택 세그먼트 레지스터(SS)와 스택 포인터 레지스터(SP), 그리고 베이스 포인터 레지스터(BP)가 그것이다.
스택 세그먼트 레지스터(SS)는 스택 영역으로 사용할 세그먼트의 기준 주소를 지정한다.
스택 포인터 레지스터(SP)는 데이터를 삽입하고 제거하는 상위(TOP)을 지정한다.
마지막으로 베이스 포인터 레지스터(BP)는 스택의 기준 주소를 임시로 지정할 때 사용한다.
16비트 모드는 세그먼테이션 방식으로 어드레스를 변환하므로 스택 세그먼트 레지스터를 사용해서 최대 64KB(0x10000)를 스택 영역으로 지정할 수 있다.
스택 세그먼트 레지스터(SS)에 0x0000을 설정한다면 사용가능한 영역은 0x00000~0x0FFFF까지가 되며, 스택 세그먼트 레지스터(SS)에 0x1000을 설정한다면 사용 가능한 영역은 0x010000~0x01FFFF까지가 된다.
스택 세그먼트 레지스터(SS)로 스택 세그먼트의 범위는 지정할 수 잇지만, 실제 스택의 크기는 지정할 수 없다.
스택의 실제 크기는 스택 포인터 레지스터(SP)와 베이스 포인터 레지스터(BP)의 조깃값으로 지정한다.
x86프로세서의 스택은 아래와 같이 데이터가 삽입될때마다 스택의 상위(TOP)를 나타내는 스택 포인터 레지스터(SS)가 낮은 어드레스(0x00에 가까운 어드레스로 이동한다.
따라서 두 레지스터의 초깃값을 어떻게 설정하는가에 따라서 스택의 크기가 결정된다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img4.jpg)

이러한 내용을 참고하여 부트로더에 스택을 생성해 보겠다.
먼저 스택으로 사용할 영역을 결정해야하는데, 0x010000(64KB) 어드레스부터는 OS 이미지가 로딩되므로 0x010000이하, 즉 0x0000:0000~0x0000:FFFF 영역을 사용하겠다.
따라서 스택 세그머늩 레지스터(SS)의 값은 0x0000으로 설정하겠다.
또한 스택은 넉넉한 거싱 좋으므로 스택 포인터 레지스터와 베이스포인터 레즈서터를 0xFFFF로 설정하여, 스택 영여그이 크기를 세그먼트의 최대크기로 지정하겠다.
아래 소스가 부트로더 앞부분에 추가될 스택 초기화 코드이다.

``` asm
; 스택을 0x0000:0000~0x0000:FFFF 영역에 64KB 크기로 생성
mov ax, 0x0000  ; 스택 세그먼틔 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
mov as, ax      ; SS 세그먼트 레지스터에 설정
mov sp, 0xFFFE  ; SP 레지스터의 어드레스를 0xFFFE로 설정
mov bp, 0xFFFE  ; BP 레지스터의 어드레스를 0xFFFE로 설정
```

이제 스택 설정이 끝났으므로, 메시지 출력 함수를 수정하겠다.
메시지를 출력하는 핵심코드는 대부분 같다.
함수에서 사용하느 레지스터르 저장하고, 복구하는 코드와 넘겨받은 파라미터를 스택에서 꺼내는 코드 정도만 추가하면 된다.
x86 프로세서는 스택 작업을 처리하는 두 가지 명령 push, pop을 지원하며, 각 명령은 스택에 데이터를 넣고 꺼낸다.
push 명령은 SP 레지스터가 가리키는 어드레스에 데이터를 저장하고 SP 레지스터를 감소시키며, pop명령은 반대로 SP 레지스터를 증가시킨다.
push 와 pop 명령은 SP 레지스터와 관계가 있으므로 스택에 많은 데이터를 넣거나 빼야한다면 push와 pop명령 대신 데이터를 스택에 직접 복사하고 나서 SP 레지스터의 값을 변경하는 방법을 같은 결과를 얻을 수 있다.

화면에서 원하는 위치에 문자열을 출력하려면 X좌표, Y좌표, 출력할 문자열 어드레스가 필요하다.
이 세가지를 함수 파라미터로 정의하고 스택에 삽입하는 순서를 정하겠다.
만일 다른 라이브러리나 다른 언어와 같이 사용하지 않는다면 스택에 삽입하는 순서를 임의로 정해도 괜찮다.
즉 호출하는 쪽과 호출되는 쪽에서 같은 순서로 스택에서 데이터를 꺼내기만 하면 정상적으로 처리할 수 있다.
하지만 앞으로 C언어와 연계를 고려한다면 중복 작업을 피할 수 있게 C언어의 호출 규약(cdecl 방식)을 따르는 펴닝 좋다.
C언어는 파라미터 역순(오른쪽에서 왼쪽)으로 삽입하여 스택에서 꺼낸 순서가 파라미터 순서와 같게 한다.
아래 소스코드는 C언어와 어셈블리어으이 함수 호출 코드를 비교한 것이다.
파라미터는 오른쪽에서 왼쪽 방향으로 스택에 삽입하고, 함수 호출이 끝난 후에 스택을 정리하는 것을 볼 수 있다. (어셈블리어 코드에서 word는 메모리에 접근할 때 2바이트(WORD) 단위로 접근하라는 것을 의미한다)

C언어의 함수 호출 코드
``` C
PrintMessage(iX, iY, pcString);
```

어셈블리어의 함수 호출 코드
``` asm
push word [ pcString ]  ; 문자열의 어드레스를 스택에 삽입
push word [ iY ]        ; 화면의 Y좌표를 스택에 삽입
push word [ iX ]        ; 화면의 X좌표를 스택에 삽입
call PRINTMESSAGE       ; PRINTMESSAGE 함수 호출
add sp, 6               ; 스택에 삽입된 함수 파라미터 3개, (2바이트 * 3)를 제거
```

위의 코드에서 함수를 호출하고 난 뒤, 스택 포인터(SP) 레지스터에 6을 더하는 이유는 함수 파라미터로 스택에 삽입된 값을 제거하기 위함이다.
16비트 모드에서는 스택에 2바이트(WORD) 크기로 삽입/제거되고 삽입은 스택 포인터 레지스터(SP)를 아래로 이동시킨다.
따라서 파라미터 3개가 삽입되면 삽입되기 전의 위치에서 -6(2바이트 * 3)만큼 이동할 것이다.
함수 수행이 끝난후, 스택을 다시 원래대로 복원하려면 감소한 만큼 더해주면 되므로 6을 더하는 것이다.


함수를 호출하는 코드를 살펴봣으니 호출되는 쪽 코드를 살펴보겠다.
호출되는 함수는 파라미터가 순서대로 삽입되어 있다는 것을 이미 알고 있다.
따라서 스택의 특정 위치를 기준으로 오프셋을 이용해 접근하면 파라미터를 찾게 된다.
그런데 여기서 문제가 한 가지 있다.
스택의 상위(TOP)을 의미하는 스택 포인터 레지스터(SP)는 스택 관련 명령(push, pop)에 따라 계속 변한다는 것이다.
스택에 삽입된 파라미터에 접근하려면 시시가각 변하는 스택 포인터 레지스터(SP)대신 스택에 고정된 갑승ㄹ 가리키는 레지스터를 사용하는거싱 편리하다.
이러한 역할을 하는 거싱 베이트 포인트 레지스터(BP)이며, 호출된 함수는 베이스 포인터 레지스터(BP) + 오프셋으로 파라미터에 접근하게 된다.

호출되는 함수에 추가하는 부분으 파라미터에 접근하는 코드만이 아니다.
호출된 함수가 작업을 마치고 호출한 코드로 복귀했을때 코드가 정상적으로 수행되려면 호출되기 전후의 레지스터 상태가 같아야 한다.
이를 위해서 호출되는 함수에서는 자신이 사용하는 레지스터의 값을 미리 스택에 저장해두고, 수행이 끝나면 이를 복원하여 호출한 이후의 코드 수행에 영향을 미치지 않아야 한다.
함수의 이러한 특징 때문에 대부분 어셈블리어 함수는 다음과 같은 형태로 정형화되어있다.

``` asm
push bp     ; 베이스 포인터 레지스터(BP)를 스택에 삽입
mov bp, sp  ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
            ; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
            ; 호출된 직후의 SP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함
push es     ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
push si     ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원
push di
push ax
push cx
push dx

; ~~ 생략 ~~

mov ax, word [ bp + 4 ]     ; 파라미터 1(iX, 화면 X 좌표)
mov bx, word [ bp + 6 ]     ; 파라미터 2(iX, 화면 Y 좌표)
mov cx, word [ bp + 8 ]     ; 파라미터 3(pcString, 출력할 문자열의 어드레스)

; ~~ 생략 ~~

pop dx      ; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에 삽입된 값을 이용해서 복원
pop cs      ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다
pop ax
pop di
pop si
pop es
pop bp      ; 베이트 포인터 레지스터(BP) 복원
ret         ; 함수를 호출한 다음 코드의 위치로 복귀
```

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img5.jpg)

지금까지 내용을 바탕으로 기존의 메시지 출력 코드를 PRINTMESSAGE 함수로 수정해 보겠다.
핵심 코드는 같고 파라미터로 출력할 화면 어드레스를 계산하는 부분만 추가했다.
수정된 PRINTMESSAGE 함수의 소스코드는 다음과 같다.

``` asm
; 메시지를 출력하는 함수
;   PARAM: x좌표, y좌표, 문자열
PRINTMESSAGE:
    push bp     ; 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov bp, sp  ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
                ; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
                ; 호출된 직후의 SP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함
    push es     ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
    push si     ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원
    push di
    push ax
    push cx
    push dx
    
    ; ES 세그먼트 레지스터에 비디오 모드 에드레스 설정
    mov ax, 0xB800          ; 비디오 메모리 시작 어드레스(0xB8000)를 세그먼트 레지스터 값으로 변환
    mov es, ax              ; ES 세그먼트 레지스터에 설정
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; X, Y의 좌표로 비디오 메모리의 어드레스를 계산함
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Y 좌표를 이용해서 먼저 라인 어드레스를 구함
    mov ax, word [ bp + 6 ] ; 파라미터 2(Y좌표)를 AX 레지스터에 설정
    mov si, 160             ; 한 라인의 바이트 수(2 * 80 컬럼)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 Y어드레스 계산
    mov di, ax              ; 계산된 화면 Y 어드레스를 DI 레지스터에 설정
    
    ; X 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함
    mov ax, word [ bp + 4 ] ; 파라미터 1(X좌표)를 AX 레지스터에 설정
    mov si, 2               ; 한 문자를 나타내는 바이트수(2)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 X 어드레스를 계산
    add di, ax              ; 화면 Y 어드레스와 계산된 X 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산
    
    ; 출력할 문자열의 어드레스
    mov si, word [ bp + 8 ] ; 파라미터 3(출력할 문자열의 어드레스
    
.MESSAGELOOP:               ; 메시지를 출력하는 루프
    mov cl, byte [ si ]     ; SI 레지스터가 가리키는 문자열 위치에서 한 문자를 CL 레지스터에 복사
                            ; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
                            ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
    
    cmp cl, 0               ; 복사된 문자와 0을 비교
    je  .MESSAGEEND         ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료
    
    mov byte [ es: di ], cl ; 0이 아니라면 메모리 어드레스 0xB800:di에 문자를 출력
    
    add si, 1               ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2               ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동
                            ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함 
                            
    jmp .MESSAGELOOP        ; 메시지 출력 루프로 이동하여 다음 문자를 출력

.MESSAGEEND:
    pop dx      ; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에 삽입된 값을 이용해서 복원
    pop cs      ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다
    pop ax
    pop di
    pop si
    pop es
    pop bp      ; 베이트 포인터 레지스터(BP) 복원
    ret         ; 함수를 호출한 다음 코드의 위치로 복귀
```
