# 플로피 디스크에서 OS이미지를 로딩하자

## BIOS 서비스와 소프트웨어 인터럽트
BIOS는 키보드/마우스에서 디스크나 프린터까지 거의 모든 PC 주변기기를 제어하는 기능을 제공한다.
16비트 OS를 개발한다고하면 BIOS의 기능만 활용해도 OS를 개발할 수 있다.

BIOS는 우리가 일반적으로 많이 쓰는 라이브러리(Library) 파일과 달리 자신의 기능을 특별한 방법으로 외부에 제공한다.
함수의 어드레스를 인터럽트 벡터 테이블(Interrupt Vector Table)에 넣어두고, 소프트웨어 인터럽트(SWI, Software Interrupt)를 호출하는 방법을 사용한다.
인터럽트 벡터 테이블은 메모리 어드레스 0에 있는 테이블로 특정 번호의 인터럽트가 발생했을때 인터럽트를 처리하는 함수(인터럽트 핸들러, Interrupt Handler) 검색에 사용한다.
테이블의 각 항목은 인덱스에 해당하는 인터럽트가 발생했을 때 처리하는 함수 어드레스가 저장되어있으며, 각 항목은 크기가 4바이트이다.
또한 인터럽트는 최대 256개 까지 설정할 수 잇으므로 리얼 모드의 인터럽트 벡터 크기는 최대 256 * 4 = 1024바이트가 된다.
아래 표는 리얼모드에서 사용하는 인터럽트 벡터 테이블의 내용이다.
항목이 많아서 중요한 부분만 발췌했다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img1.jpg)

BIOS가 제공하는 디스크 서비스를 사용하려면 위에 나와있듯이 0x13 인터럽트를 발생시켜야한다.
이는 우리가 임의로 인터럽트를 발생시킬 수 잇어야 한다는것을 의미하며, 이때 소프트웨어 인터럽트 명령을 사용한다.
SWI는 CPU에 가상으로 특정 인터럽트가 발생했다고 알리는 명령어로 int 0x13 형태로 사용한다.
만든 함수의 어드레스를 인터럽트 벡터 테이블에 넣어뒀다면 int 명령으로 언제든지 해당 함수로 이동할 수 있다.

BIOS 서비스는 SWI를 통해 호출할 수 있지만 BIOS도 만능은 아니어서 작업에 관련된 파라미터를 넘겨줘야한다.
파라미터는 레지스터를 이용해서 넘겨준다.
BIOS의 기능을 사용할 때는 AX, BX, CX, DX 레지스터와 ES 세그먼트 레지스터를 사용해서 파라미터를 넘겨주며 결과값도 레지스터를 통해 넘겨받는다.
물론 BIOS  서비스 마다 요구하는 파라미터의 수가 다르므로 서비스를 호출할 때 파라미터로 정의된 레지스터를 꼭 확인해야한다.
디스크 관련 서비스 주엥 리셋과 섹터 읽기 기능을 예로 들면 아래 표와 같다.
보면 AX레지스터는 기능 선택과 처리한 결과값을 받을 때 공통으로 사용되는 것을 알 수 잇따.
이는 BIOS의 디스크관련 서비스 뿐만 아니라 다른 서비스에도 마찬가지로 적용되는 규칙이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img2.jpg)


## OS 이미지 로딩 기능 구현
### 디스크 읽기 기능 구현
MINT64 OS의 이미지는 크게 부트로더, 보호 모드 커널, IA-32e 모드 커널로 구성되며, 각 부분은 섹터 단위로 정렬해서 하나의 부팅 이미지 파일로 합친다.
따라서 디스크의 두번째 섹터부터 읽어서 특정 메모리 어드레스에 순서대로 복사하면 이미지 로딩은 끝이다.
MINT64 OS는 OS 이미지 를 0x10000(64Kbyte)에 로딩해서 실행한다.
하지만, OS 이미지를 반드시 0x10000 위치에 로딩해야 실행되는것은 아니다.
부트로더 이후(0x07C00)에 연속해서 복사해도 OS실행에 문제는 없다.
MINT 64 OS는 0x10000하위 영역을 다른 용도로 사용하기에 남겨둔 것이다.

플로피 디스크의 첫 번째 섹터는 부트로더로 BIOS가 메모리에 로딩한다.
따라서 플로피 디스크의 두 번째 섹터부터 OS 이미지 크기만큼 읽어서 메모리에 복사하면 된다.
플로피 디스크의 섹터는 섹터 -> 헤드 -> 트랙의 순서로 배열되어 잇으므로 이 순서만 지킨다면 큰 문제 없이 로딩할 수 잇다.
섹터 배열 순서를 고려하여 작성한 C코드는 아래와 같다.
섹터 번호를 순서대로 증가시키며 읽다가 마지막 섹터에서 헤드와 트랙 번호를 증가시키는 것이 핵심 포인트이다.

``` C
int main(int argc, char *argv[]) {
    int iTotalSectorCount = 1024;
    int iSectorNumber = 2;
    int iHeadNumber = 0;
    int iTrackNumber = 0;
    // 실제 이미지를 복사할 어드레스(물리 주소)
    char *pcTargetAddress = (char *) 0x10000;

    while (1) {
        // 전체 섹터 수를 하나씩 감소시키면서 0이 될 때까지 섹터를 복사
        if (iTotalSectorCount == 0)
            break;
        iTotalSectorCount--;

        // 1 섹터를 읽어들여서 메모리 어드레스에 복사
        // BIOSReadOneSector: BIOS의 세거 읽기 기능을 호출하는 임의의 함수
        if (BIOSReadOneSector(iSectorNumber, iHeadNumber, iTrackNumber, pcTargetAddress) == ERROR)
            HandleDiskError();

        // 1 섹터는 512(0x200) 바이트이므로 복사한 수만큼 어드레스 증가 
        pcTargetAddress = pcTargetAddress + 0x200;

        // 섹터 -> 헤드 -> 트랙 순으로 번호 증가
        iSectorNumber++;
        if (iSectorNumber < 19)
            continue;

        // 헤드의 번호는 0과 1이 반복되므로 이를 편리하게 처리하기위해 XOR 연산을 사용
        // iHeadNumber = (iHeadNumber == 0x00) ? 0x00 : 0x01; 과 같은 의미
        iHeadNumber = iHeadNumber ^ 0x01;
        iSectorNumber = 1;

        if (iHeadNumber != 0)
            continue;

        iTrackNumber++;
    }
    return 0;
}

int HandleDiskError() {
    printf("DISK Error!!");
    while (1);
}
```

위의 C언어 코드를 참고하여 어셈블리어 소스 코드를 작성하면 아래와 같다.

``` asm
TOTALSECTORCOUNT:   dw  1024    ; 부트로더를 제외한 MINT64 OS이미지의 크기
                                ; 최대 1152 섹터(0x90000byte)까지 가능
SECTORNUMBER:       db  0x02    ; OS 이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER:         db  0x00    ; OS 이미지가 시작하는 헤드 번호를 저장하는 영역
TRACKNUMBER:        db  0x00    ; OS 이미지가 시작하는 트랙 번호를 저장하는 영역

    ;디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x1000으로 설정
    mov si, 0x1000      ; OS 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환
    mov es, si          ; ES 세그먼트에 값 설정
    mov bx, 0x0000      ; BX 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

    mov di, word [ TOTALSECTORCOUNT ]   ; 복사할 OS 이미지의 섹터 수를 DI 레지스터에 설정

READDATA:               ; 디스크를 읽는 코드의 시작
    ; 모든 섹터를 다 읽었는지 확인
    cmp di, 0           ; 복사할 OS의 이미지의 섹터 수를 0과 비교
    je READEND          ; 복사할 섹터 수가 0이라면 다 복사했으므로 READEND로 이동
    sub di, 0x01        ; 복사할 섹터 수를 1 감소

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; BIOS Read Function 호출
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov ah, 0x02                    ; BIOS 서비스 번호 2(Read Sector)
    mov al, 0x1                     ; 읽을 섹터 수는 1
    mov ch, byte [ TRACKNUMBER ]    ; 읽을 트랙 번호 설정
    mov cl, byte [ SECTORNUMBER ]   ; 읽을 섹터 번호 설정
    mov dh, byte [ HEADNUMBER ]     ; 읽을 헤드 번호 설정
    mov dl, 0x00                    ; 읽을 드라이브 번호(0=Floppy) 설정
    int 0x13                        ; 인터럽트 서비스 수행
    jc HANDLEDISKERROR              ; 에러가 발생했다면 HANDLEDISKERROR로 이동

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 복사할 어드레스와 트랙, 헤드 섹터 어드레스 계산
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    add si, 0x0020      ; 512(0x200)바이트 만큼 읽었으므로 이를 세그먼트 레지스터 값으로 변환
    mov es, si          ; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터만큼 증가

    ; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
    ; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행
    mov al, byte [ SECTORNUMBER ]   ; 섹터 번호를 AL레지스터에 설정
    add al, 0x01                    ; 섹터 번호를 1 증가
    mov byte [ SECTORNUMBER ], al   ; 증가시킨 섹터 번호를 SECTORNUMBER에 다시 설정
    cmp al, 19                      ; 증가시킨 섹터 번호를 19와 비교
    jl READDATA                     ; 섹터 번호가 19미만이라면 READDATA로 이동
    
    ; 마지막 섹터까지 읽었으면(섹터 번호가 19이면) 헤드를 토글(0->1, 1->0)하고, 섹터 번호를 1로 설정
    xor byte [ HEADNUMBER ], 0x01   ; 헤드 번호를 0x01과 XOR하여 토글(0->1, 1->0)
    mov byte [ SECTORNUMBER ], 0x01 ; 섹터 번호를 다시 1 로 설정
    
    ; 만약 헤드가 1->0으로 바뀌었으면 양쪽 헤드를 모두 읽은것이므로 아래로 이동하여 트랙 번호를 1 증가
    cmp byte [ HEADNUMBER ], 0x00   ; 헤드 번호를 0x00과 비교
    jne READDATA                    ; 헤드 번호가 0이 아니면 READDATA로 이동
    
    ; 트랙을 1 증가시킨 후, 다시 섹터 읽기로 이동
    add byte [ TRACKNUMBER ] , 0x01 ; 트랙 번호를 1 증가
    jmp READDATA                    ; READDATA로 이동
READEND:

HANDLEDISKERROR:    ; 에러를 처리하는 코드
    ; 생략
```

위의 어셈블리어 소스 코드와 디스크 리셋 기능만 부트로더에 추가하면 로딩할 준비가 끝난다.
그런데 기능은 구현했지만 화면에 출력하는 코드가 없어서 진행 상황이나 완료 유무를 확인하기 어렵다.
이번에는 화면에 진행 상태를 출력하도록 코드를 추가해보겠다

앞에서 환영 메시지를 출력하는 코드를 구현했다.
하지만 함수 형태로 구현하지 않아서 원하는 곳에서 호출할 수 없다.
무네즌 코드 구조뿐만 아니라 함수 호출에 필요한 핵심 자료구조또한 빠져있다는것이다.
이를 보완하여 함수 호출이 가능한 구조로 만들어 보겠다.

### 스택 초기화와 함수구현
x86 프로세서에서 함수를 사용하려면 스택(Stack)이 꼭 필요하다.
스택은 아래와 같이 데이터를 삽입하는 포인트와 제거하는 포인트가 같아서, 마지막에 들어간 데이터가 가장 먼저 나오는 형태의 자료구조(Last in, First out)이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img3.jpg)

x86 프로세서에서는 함수를 호출한 코드의 다음 어드레스, 즉 되돌아갈 어드레스(이하 복귀 어드레스, Return Address)를 저장하는 용도로 스택을 사용한다.
함수를 호출하면 프로세서가 자동으로 되돌아올 어드레스를 스택에 저장하며, 호출된 함수에서 되돌아감(ret)을 요청하면 자동으로 스택에서 어드레스를 꺼내 호출한 다음 어드레스로 이동하는 것이다.
스택은 복귀 어드레스를 저장하는 역할뿐만 아니라 함수의 파라미터를 저장하는 역할도 겸한다.
호출하는 쪽(Caller)과 호출되는 쪽 (Callee)은 정해진 규칙에 따랄 파라미터를 스택에 저장함으로서 협엄할 수 있다.

함수 호출을 위해 가장 먼저 해야할 일은 스택 생성이다.
x86프로세서는 스택관련 레지스터가 세가지 있다.
스택 세그먼트 레지스터(SS)와 스택 포인터 레지스터(SP), 그리고 베이스 포인터 레지스터(BP)가 그것이다.
스택 세그먼트 레지스터(SS)는 스택 영역으로 사용할 세그먼트의 기준 주소를 지정한다.
스택 포인터 레지스터(SP)는 데이터를 삽입하고 제거하는 상위(TOP)을 지정한다.
마지막으로 베이스 포인터 레지스터(BP)는 스택의 기준 주소를 임시로 지정할 때 사용한다.
16비트 모드는 세그먼테이션 방식으로 어드레스를 변환하므로 스택 세그먼트 레지스터를 사용해서 최대 64KB(0x10000)를 스택 영역으로 지정할 수 있다.
스택 세그먼트 레지스터(SS)에 0x0000을 설정한다면 사용가능한 영역은 0x00000~0x0FFFF까지가 되며, 스택 세그먼트 레지스터(SS)에 0x1000을 설정한다면 사용 가능한 영역은 0x010000~0x01FFFF까지가 된다.
스택 세그먼트 레지스터(SS)로 스택 세그먼트의 범위는 지정할 수 잇지만, 실제 스택의 크기는 지정할 수 없다.
스택의 실제 크기는 스택 포인터 레지스터(SP)와 베이스 포인터 레지스터(BP)의 조깃값으로 지정한다.
x86프로세서의 스택은 아래와 같이 데이터가 삽입될때마다 스택의 상위(TOP)를 나타내는 스택 포인터 레지스터(SS)가 낮은 어드레스(0x00에 가까운 어드레스로 이동한다.
따라서 두 레지스터의 초깃값을 어떻게 설정하는가에 따라서 스택의 크기가 결정된다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img4.jpg)

이러한 내용을 참고하여 부트로더에 스택을 생성해 보겠다.
먼저 스택으로 사용할 영역을 결정해야하는데, 0x010000(64KB) 어드레스부터는 OS 이미지가 로딩되므로 0x010000이하, 즉 0x0000:0000~0x0000:FFFF 영역을 사용하겠다.
따라서 스택 세그머늩 레지스터(SS)의 값은 0x0000으로 설정하겠다.
또한 스택은 넉넉한 거싱 좋으므로 스택 포인터 레지스터와 베이스포인터 레즈서터를 0xFFFF로 설정하여, 스택 영여그이 크기를 세그먼트의 최대크기로 지정하겠다.
아래 소스가 부트로더 앞부분에 추가될 스택 초기화 코드이다.

``` asm
; 스택을 0x0000:0000~0x0000:FFFF 영역에 64KB 크기로 생성
mov ax, 0x0000  ; 스택 세그먼틔 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
mov as, ax      ; SS 세그먼트 레지스터에 설정
mov sp, 0xFFFE  ; SP 레지스터의 어드레스를 0xFFFE로 설정
mov bp, 0xFFFE  ; BP 레지스터의 어드레스를 0xFFFE로 설정
```

이제 스택 설정이 끝났으므로, 메시지 출력 함수를 수정하겠다.
메시지를 출력하는 핵심코드는 대부분 같다.
함수에서 사용하느 레지스터르 저장하고, 복구하는 코드와 넘겨받은 파라미터를 스택에서 꺼내는 코드 정도만 추가하면 된다.
x86 프로세서는 스택 작업을 처리하는 두 가지 명령 push, pop을 지원하며, 각 명령은 스택에 데이터를 넣고 꺼낸다.
push 명령은 SP 레지스터가 가리키는 어드레스에 데이터를 저장하고 SP 레지스터를 감소시키며, pop명령은 반대로 SP 레지스터를 증가시킨다.
push 와 pop 명령은 SP 레지스터와 관계가 있으므로 스택에 많은 데이터를 넣거나 빼야한다면 push와 pop명령 대신 데이터를 스택에 직접 복사하고 나서 SP 레지스터의 값을 변경하는 방법을 같은 결과를 얻을 수 있다.

화면에서 원하는 위치에 문자열을 출력하려면 X좌표, Y좌표, 출력할 문자열 어드레스가 필요하다.
이 세가지를 함수 파라미터로 정의하고 스택에 삽입하는 순서를 정하겠다.
만일 다른 라이브러리나 다른 언어와 같이 사용하지 않는다면 스택에 삽입하는 순서를 임의로 정해도 괜찮다.
즉 호출하는 쪽과 호출되는 쪽에서 같은 순서로 스택에서 데이터를 꺼내기만 하면 정상적으로 처리할 수 있다.
하지만 앞으로 C언어와 연계를 고려한다면 중복 작업을 피할 수 있게 C언어의 호출 규약(cdecl 방식)을 따르는 펴닝 좋다.
C언어는 파라미터 역순(오른쪽에서 왼쪽)으로 삽입하여 스택에서 꺼낸 순서가 파라미터 순서와 같게 한다.
아래 소스코드는 C언어와 어셈블리어으이 함수 호출 코드를 비교한 것이다.
파라미터는 오른쪽에서 왼쪽 방향으로 스택에 삽입하고, 함수 호출이 끝난 후에 스택을 정리하는 것을 볼 수 있다. (어셈블리어 코드에서 word는 메모리에 접근할 때 2바이트(WORD) 단위로 접근하라는 것을 의미한다)

C언어의 함수 호출 코드
``` C
PrintMessage(iX, iY, pcString);
```

어셈블리어의 함수 호출 코드
``` asm
push word [ pcString ]  ; 문자열의 어드레스를 스택에 삽입
push word [ iY ]        ; 화면의 Y좌표를 스택에 삽입
push word [ iX ]        ; 화면의 X좌표를 스택에 삽입
call PRINTMESSAGE       ; PRINTMESSAGE 함수 호출
add sp, 6               ; 스택에 삽입된 함수 파라미터 3개, (2바이트 * 3)를 제거
```

위의 코드에서 함수를 호출하고 난 뒤, 스택 포인터(SP) 레지스터에 6을 더하는 이유는 함수 파라미터로 스택에 삽입된 값을 제거하기 위함이다.
16비트 모드에서는 스택에 2바이트(WORD) 크기로 삽입/제거되고 삽입은 스택 포인터 레지스터(SP)를 아래로 이동시킨다.
따라서 파라미터 3개가 삽입되면 삽입되기 전의 위치에서 -6(2바이트 * 3)만큼 이동할 것이다.
함수 수행이 끝난후, 스택을 다시 원래대로 복원하려면 감소한 만큼 더해주면 되므로 6을 더하는 것이다.


함수를 호출하는 코드를 살펴봣으니 호출되는 쪽 코드를 살펴보겠다.
호출되는 함수는 파라미터가 순서대로 삽입되어 있다는 것을 이미 알고 있다.
따라서 스택의 특정 위치를 기준으로 오프셋을 이용해 접근하면 파라미터를 찾게 된다.
그런데 여기서 문제가 한 가지 있다.
스택의 상위(TOP)을 의미하는 스택 포인터 레지스터(SP)는 스택 관련 명령(push, pop)에 따라 계속 변한다는 것이다.
스택에 삽입된 파라미터에 접근하려면 시시가각 변하는 스택 포인터 레지스터(SP)대신 스택에 고정된 갑승ㄹ 가리키는 레지스터를 사용하는거싱 편리하다.
이러한 역할을 하는 거싱 베이트 포인트 레지스터(BP)이며, 호출된 함수는 베이스 포인터 레지스터(BP) + 오프셋으로 파라미터에 접근하게 된다.

호출되는 함수에 추가하는 부분으 파라미터에 접근하는 코드만이 아니다.
호출된 함수가 작업을 마치고 호출한 코드로 복귀했을때 코드가 정상적으로 수행되려면 호출되기 전후의 레지스터 상태가 같아야 한다.
이를 위해서 호출되는 함수에서는 자신이 사용하는 레지스터의 값을 미리 스택에 저장해두고, 수행이 끝나면 이를 복원하여 호출한 이후의 코드 수행에 영향을 미치지 않아야 한다.
함수의 이러한 특징 때문에 대부분 어셈블리어 함수는 다음과 같은 형태로 정형화되어있다.

``` asm
push bp     ; 베이스 포인터 레지스터(BP)를 스택에 삽입
mov bp, sp  ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
            ; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
            ; 호출된 직후의 SP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함
push es     ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
push si     ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원
push di
push ax
push cx
push dx

; ~~ 생략 ~~

mov ax, word [ bp + 4 ]     ; 파라미터 1(iX, 화면 X 좌표)
mov bx, word [ bp + 6 ]     ; 파라미터 2(iX, 화면 Y 좌표)
mov cx, word [ bp + 8 ]     ; 파라미터 3(pcString, 출력할 문자열의 어드레스)

; ~~ 생략 ~~

pop dx      ; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에 삽입된 값을 이용해서 복원
pop cs      ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다
pop ax
pop di
pop si
pop es
pop bp      ; 베이트 포인터 레지스터(BP) 복원
ret         ; 함수를 호출한 다음 코드의 위치로 복귀
```

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img5.jpg)

지금까지 내용을 바탕으로 기존의 메시지 출력 코드를 PRINTMESSAGE 함수로 수정해 보겠다.
핵심 코드는 같고 파라미터로 출력할 화면 어드레스를 계산하는 부분만 추가했다.
수정된 PRINTMESSAGE 함수의 소스코드는 다음과 같다.

``` asm
; 메시지를 출력하는 함수
;   PARAM: x좌표, y좌표, 문자열
PRINTMESSAGE:
    push bp     ; 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov bp, sp  ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
                ; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
                ; 호출된 직후의 SP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함
    push es     ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
    push si     ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원
    push di
    push ax
    push cx
    push dx
    
    ; ES 세그먼트 레지스터에 비디오 모드 에드레스 설정
    mov ax, 0xB800          ; 비디오 메모리 시작 어드레스(0xB8000)를 세그먼트 레지스터 값으로 변환
    mov es, ax              ; ES 세그먼트 레지스터에 설정
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; X, Y의 좌표로 비디오 메모리의 어드레스를 계산함
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Y 좌표를 이용해서 먼저 라인 어드레스를 구함
    mov ax, word [ bp + 6 ] ; 파라미터 2(Y좌표)를 AX 레지스터에 설정
    mov si, 160             ; 한 라인의 바이트 수(2 * 80 컬럼)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 Y어드레스 계산
    mov di, ax              ; 계산된 화면 Y 어드레스를 DI 레지스터에 설정
    
    ; X 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함
    mov ax, word [ bp + 4 ] ; 파라미터 1(X좌표)를 AX 레지스터에 설정
    mov si, 2               ; 한 문자를 나타내는 바이트수(2)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 X 어드레스를 계산
    add di, ax              ; 화면 Y 어드레스와 계산된 X 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산
    
    ; 출력할 문자열의 어드레스
    mov si, word [ bp + 8 ] ; 파라미터 3(출력할 문자열의 어드레스
    
.MESSAGELOOP:               ; 메시지를 출력하는 루프
    mov cl, byte [ si ]     ; SI 레지스터가 가리키는 문자열 위치에서 한 문자를 CL 레지스터에 복사
                            ; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
                            ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
    
    cmp cl, 0               ; 복사된 문자와 0을 비교
    je  .MESSAGEEND         ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료
    
    mov byte [ es: di ], cl ; 0이 아니라면 메모리 어드레스 0xB800:di에 문자를 출력
    
    add si, 1               ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2               ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동
                            ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함 
                            
    jmp .MESSAGELOOP        ; 메시지 출력 루프로 이동하여 다음 문자를 출력

.MESSAGEEND:
    pop dx      ; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에 삽입된 값을 이용해서 복원
    pop cs      ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다
    pop ax
    pop di
    pop si
    pop es
    pop bp      ; 베이트 포인터 레지스터(BP) 복원
    ret         ; 함수를 호출한 다음 코드의 위치로 복귀
```

### 보호 모드에서 사용되는 세 가지 함수 호출 규약
함수 호출에 대한 이야기가 나왔으니, 보호 모드에서 주로 사용하는 함수 호출 규약 세 가지를 잠깐 살펴보겠다.
호출 규약(Calling Convention)은 함수를 호출할 때 파라미터와 복귀 어드레스 등을 지정하는 규칙이다.
보호 모드에서 사용하는 대표적인 호출 규약에는 stdcall, cdecl, fastcall이 있으며 약간ㅆ기 차이가 있다.
stdcall 방식은 파라미터를 스택에 저장하며, 호출된 쪽에서 스택을 정리한다.
cdecl 방식식도 역시 파라미터를 스택에 저장하지만, 함수를 호출한 ㅉ고에서 스택을 정리한다.
fastcall 방식은 일부 파라미터를 레지스터에 저장하는 것을 제외하면 stdcall 방식과 같다.
세 가지 방식의 자세한 내용은 다음의 C언어 함수 호출 예제를 어셈블리어로 구현한 소스코드와 비교하며 설명하겠다.

함수 호출 예

``` C
int Add(int iA, int iB, int iC) {
    return iA + iB + iC;
}

void main() {
    int iReturn;
    iReturn  = Add(1, 2, 3);
}
```

stdcall(Standard call)은 파라미터를 스택에 넣을때 오른쪽에서 왼쪽 순서로 집어 넣는다.
그리고 함수의 반환값은 EAX 레지스터(32비트 AX레지스터)를 사용하며 스택에서 파라미터를 제거하는 작업을 호출된 함수가 처리하게 한다.

```
Add:                            ; Add 함수
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    mov eax, dword [ ebp + 8 ]  ; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
                                ; 보호 모드는 스택의 크기가 4바이트로 리얼 모드의 2배이므로 파라미터 오프셋 또한 4*2가 되어 8로 변경. 이하 동일
    add eax, dword [ ebp + 12 ] ; 파라미터 2(iB)를 AX 레지스터와 더함
    add eax, dword [ ebp + 16 ] ; 파라미터 3(iC)를 AX 레지스터와 더함
    pop ebp                     ; 베이스 포인터 레지스터(BP)를 스택에서 복원
    ret 12                      ; 스택에 삽입된 파라미터 3개를 제거(3*4)한 후 호출한 함수로 복귀 
                                ; "add esp, 12" "ret"와 같은 역활
                                
main:
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    sub esp, 8                  ; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한 공간 할당
    push 3                      ; 파라미터 3 삽입
    push 2                      ; 파라미터 2 삽입
    push 1                      ; 파라미터 1 삽입
    call Add                    ; Add 함수 호출
    mov dword [ ebp - 4 ], eax  ; iReturn 변수에 Add 함수의 반환값 저장
    ret                         ; 호출한 함수로 복귀
```

cdecl(C-Declare CAll)은 stdcall과 동일하게 파라미터의 오른쪽에서 왼쪽 순서로 스택에 집어넣는다.
함수의 반환값 역시 AX 레지스터를 사용한다.
단 한가지 차이점은 스택에서 파라미터를 제거하는 작업을 호출한 함수가 대신 처리한다는 점이다.
아래 소스코드를 보며 비교해보자.

``` asm
Add:                            ; Add 함수
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    mov eax, dword [ ebp + 8 ]  ; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
                                ; 보호 모드는 스택의 크기가 4바이트로 리얼 모드의 2배이므로 파라미터 오프셋 또한 4*2가 되어 8로 변경. 이하 동일
    add eax, dword [ ebp + 12 ] ; 파라미터 2(iB)를 AX 레지스터와 더함
    add eax, dword [ ebp + 16 ] ; 파라미터 3(iC)를 AX 레지스터와 더함
    pop ebp                     ; 베이스 포인터 레지스터(BP)를 스택에서 복원
    ret                         ; 호출한 함수로 복귀

main:
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    sub esp, 8                  ; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한 공간 할당
    push 3                      ; 파라미터 3 삽입
    push 2                      ; 파라미터 2 삽입
    push 1                      ; 파라미터 1 삽입
    call Add                    ; Add 함수 호출
    mov dword [ ebp - 4 ], eax  ; iReturn 변수에 Add 함수의 반환값 저장
    add esp, 12                 ; 스택 포인터 레지스터(SP)에 12를 더하여 삽입한 파라미터 3개(3 * 4바이트)를 제거
    ret                         ; 호출한 함수로 복귀
```
Add 함수의 `ret`과 main 함수의 `add esp, 12` 부분이 달라졌다.

fastcall은 컴파일러마다 구현하는 방식이 조금씩 다르다.
윈도우에서 많이 쓰이는 마이크로소프트사의 컴파일러를 기준으로 설명하면, 처음 2개의 파라미터를 ECX, EDX 레지스터에 삽입하는 점을 제외하고는 stdcall과 같다.

``` asm
Add:                            ; Add 함수
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    mov eax, ecx                ; 32비트 파라미터 1(iA)을 32비트 AX 레지스터에 설정
                                ; 보호 모드는 스택의 크기가 4바이트로 리얼 모드의 2배이므로 파라미터 오프셋 또한 4*2가 되어 8로 변경. 이하 동일
    add eax, edx                ; 파라미터 2(iB)를 AX 레지스터와 더함
    add eax, dword [ ebp + 8 ]  ; 파라미터 3(iC)를 AX 레지스터와 더함
    pop ebp                     ; 베이스 포인터 레지스터(BP)를 스택에서 복원
    ret 4                       ; 호출한 함수로 복귀.
                                ; "add esp, 4" "ret"와 같은 역할

main:
    push ebp                    ; 32비트 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov ebp, esp                ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
    sub esp, 8                  ; SP 레지스터에서 8만큼 빼서 지역변수 iReturn을 위한 공간 할당
    push 3                      ; 파라미터 3 삽입, 스택을 통해 전달
    mov edx, 2                  ; 파라미터 2 삽입, 32비트 DX 레지스터를 통해 전달 
    mov ecx, 1                  ; 파라미터 1 삽입, 32비트 CX 레지스터를 통해 전달
    call Add                    ; Add 함수 호출
    mov dword [ ebp - 4 ], eax  ; iReturn 변수에 Add 함수의 반환값 저장
    ret                         ; 호출한 함수로 복귀
```

IA-32e모드의 호출규약은 fastcall을 확장한 방식이며, 보다 많은 레지스터르 파라미터 전달용으로 사용한다.
IA-32e모드로 전환되면 기존 레지스터에 8개의 범용 레지스터가 추가된다.
IA-32e모드의 호출규약은 기존 레지스터와 추가된 레지스터를 포마하여 파라미터를 최대 6개까지 전달할 수 있도록 설계되었기 때문에, 파라미터 개수만 제한하여 사용하다면 스택관련 작업을 줄일 수 있다.

``` asm
[ORG 0x00]          ; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]           ; 아래 코드를 16비트 코드로 설정

SECTION .text       ; text 섹션(세그먼트) 정의

jmp 0x07C0:START    ; CS 세그먼트 레지스터에 0x07C0을 복사하면서 START 레이블로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MINT 64 OS에 관련된 환경 설청 값
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TOTALSECTORCOUNT:   dw  1024    ; 부트로더를 제외한 MINT64 OS이미지의 크기
                                ; 최대 1152 섹터(0x90000byte)까지 가능


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
    mov ax, 0x07C0  ; 부트로더의 시작 어드레스(0x07C0)를 세그먼트 레지스터 값으로 변환
    mov ds, ax      ; DS 세그먼트 레지스터에 설정
    mov ax, 0xB800  ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환
    mov es, ax      ; ES 레지스터에 설정

    ; 스택을 0x0000:0000~0x0000:FFFF 영역에 64KB 크기로 생성
    mov ax, 0x0000  ; 스택 세그먼틔 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
    mov ss, ax      ; SS 세그먼트 레지스터에 설정
    mov sp, 0xFFFE  ; SP 레지스터의 어드레스를 0xFFFE로 설정
    mov bp, 0xFFFE  ; BP 레지스터의 어드레스를 0xFFFE로 설정


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 화면을 모두 지우고 속성값을 녹색으로 설정
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov     si, 0                   ; SI 레지스터문자열 원본 인덱스 레지스터)를 초기화

.SCREENCLEARLOOP:                   ; 화면을 지우는 루프
    mov byte [ es: si ], 0          ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제
    mov byte [ es: si + 1 ], 0x0A   ; 비디오 메모리의 속성이 위치하는 어드레스에 0x0A를 복사
    add si, 2                       ; 문자와 속성을 설정했으므로 다음 위치로 이동

    cmp si, 80 * 25 * 2             ; 화면 전체 크기는 80문자 * 25라인이다
                                    ; 출력한 문자의 수를 의미하는 SI 레지스터와 비교
    jl  .SCREENCLEARLOOP            ; SI 레지스터가 80 * 25 * 2보다 작다면 아직 지우지 못한 영역이 있으므로 .SCREENCLEARLOOP 레이블로 이동
                                    ; jl은 Jump if less의 줄임말이다.


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 화면 상단에 시작 메시지 출력
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    push MESSAGE1                   ; 출력할 메시지의 어드레스를 스택에 삽입
    push 0                          ; 화면 Y 좌표 0을 스택에 삽입
    push 0                          ; 화면 X 좌표 0을 스택에 삽입
    call PRINTMESSAGE               ; PRINTMESSAGE 함수 호출
    add sp, 6                       ; 삽입한 파라미터 제거


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; OS 이미지를 로딩한다는 메시지 출력
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    push IMAGELOADINGMESSAGE        ; 출력할 메시지의 어드레스를 스택에 삽입
    push 1                          ; 화면 Y 좌표 1을 스택에 삽입
    push 0                          ; 화면 X 좌표 0을 스택에 삽입
    call PRINTMESSAGE               ; PRINTMESSAGE 함수 호출
    add sp, 6                       ; 삽입한 파라미터 제거


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 디스크에서 OS 이미지를 로딩
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 디스크를 읽기 전에 먼저 리셋
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESETDISK:                          ; 디스크를 리셋하는 코드의 시작
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; BIOS Reset Function 호출
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 서비스 번호 0, 드라이브 번호(0=Floppy)
    mov ax, 0
    mov dl, 0
    int 0x13
    ; 에러가 발생하면 에러 처리로 이동
    jc  HANDLEDISKERROR

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 디스크에서 섹터를 읽음
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x10000으로 설정
    mov si, 0x1000                  ; OS 이미지를 복사할 어드레스(0x10000)를 세그먼트 레지스터 값으로 변환
    mov es, si                      ; ES 세그먼트 레지스터에 값 설정
    mov bx, 0x0000                  ; BX 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

    mov di, word [ TOTALSECTORCOUNT ] ; 복사할 OS 이미지의 섹터 수를 DI 레지스터에 설정

READDATA:               ; 디스크를 읽는 코드의 시작
    ; 모든 섹터를 다 읽었는지 확인
    cmp di, 0           ; 복사할 OS의 이미지의 섹터 수를 0과 비교
    je READEND          ; 복사할 섹터 수가 0이라면 다 복사했으므로 READEND로 이동
    sub di, 0x1        ; 복사할 섹터 수를 1 감소

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; BIOS Read Function 호출
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov ah, 0x02                    ; BIOS 서비스 번호 2(Read Sector)
    mov al, 0x1                     ; 읽을 섹터 수는 1
    mov ch, byte [ TRACKNUMBER ]    ; 읽을 트랙 번호 설정
    mov cl, byte [ SECTORNUMBER ]   ; 읽을 섹터 번호 설정
    mov dh, byte [ HEADNUMBER ]     ; 읽을 헤드 번호 설정
    mov dl, 0x00                    ; 읽을 드라이브 번호(0=Floppy) 설정
    int 0x13                        ; 인터럽트 서비스 수행
    jc HANDLEDISKERROR              ; 에러가 발생했다면 HANDLEDISKERROR로 이동

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 복사할 어드레스와 트랙, 헤드 섹터 어드레스 계산
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    add si, 0x0020      ; 512(0x200)바이트 만큼 읽었으므로 이를 세그먼트 레지스터 값으로 변환
    mov es, si          ; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터만큼 증가

    ; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
    ; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행
    mov al, byte [ SECTORNUMBER ]   ; 섹터 번호를 AL레지스터에 설정
    add al, 0x01                    ; 섹터 번호를 1 증가
    mov byte [ SECTORNUMBER ], al   ; 증가시킨 섹터 번호를 SECTORNUMBER에 다시 설정
    cmp al, 19                      ; 증가시킨 섹터 번호를 19와 비교
    jl READDATA                     ; 섹터 번호가 19미만이라면 READDATA로 이동

    ; 마지막 섹터까지 읽었으면(섹터 번호가 19이면) 헤드를 토글(0->1, 1->0)하고, 섹터 번호를 1로 설정
    xor byte [ HEADNUMBER ], 0x01   ; 헤드 번호를 0x01과 XOR하여 토글(0->1, 1->0)
    mov byte [ SECTORNUMBER ], 0x01 ; 섹터 번호를 다시 1 로 설정

    ; 만약 헤드가 1->0으로 바뀌었으면 양쪽 헤드를 모두 읽은것이므로 아래로 이동하여 트랙 번호를 1 증가
    cmp byte [ HEADNUMBER ], 0x00   ; 헤드 번호를 0x00과 비교
    jne READDATA                    ; 헤드 번호가 0이 아니면 READDATA로 이동

    ; 트랙을 1 증가시킨 후, 다시 섹터 읽기로 이동
    add byte [ TRACKNUMBER ] , 0x01 ; 트랙 번호를 1 증가
    jmp READDATA                    ; READDATA로 이동
READEND:
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; OS 이미지가 완료되었다는 메시지를 출력
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    push LOADINGCOMPLETEMESSAGE     ; 출력할 메시지의 어드레스를 스택에 삽입
    push 1                          ; 화면 Y 좌표 1를 스택에 삽입
    push 20                         ; 화면 X 좌표 20을 스택에 삽입
    call PRINTMESSAGE               ; PRINTMESSAGE 함수 호출
    add sp, 6                       ; 삽입한 파라미터 제거

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 로딩한 가상 OS 이미지 실행
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    jmp 0x1000:0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 함수 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 디스크 에러를 처리하는 함수
HANDLEDISKERROR:
    push DISKERRORMESSAGE   ; 에러 문자열의 어드레스를 스택에 삽입
    push 1                  ; 화면 Y 좌표 1를 스택에 삽입
    push 20                 ; 화면 X 좌표 20을 스택에 삽입
    call PRINTMESSAGE       ; PRINTMESSAGE 함수 호출
    add sp, 6               ; 삽입한 파라미터 제거

    jmp $                   ; 현재 위치에서 무한 루프 수행

; 메시지를 출력하는 함수
;   PARAM: x좌표, y좌표, 문자열
PRINTMESSAGE:
    push bp     ; 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov bp, sp  ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정
                ; 베이스 포인터 레지스터(BP)를 이용해서 파라미터에 접근할 목적
                ; 호출된 직후의 SP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함
    push es     ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
    push si     ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원
    push di
    push ax
    push cx
    push dx

    ; ES 세그먼트 레지스터에 비디오 모드 에드레스 설정
    mov ax, 0xB800          ; 비디오 메모리 시작 어드레스(0xB8000)를 세그먼트 레지스터 값으로 변환
    mov es, ax              ; ES 세그먼트 레지스터에 설정

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; X, Y의 좌표로 비디오 메모리의 어드레스를 계산함
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Y 좌표를 이용해서 먼저 라인 어드레스를 구함
    mov ax, word [ bp + 6 ] ; 파라미터 2(Y좌표)를 AX 레지스터에 설정
    mov si, 160             ; 한 라인의 바이트 수(2 * 80 컬럼)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 Y어드레스 계산
    mov di, ax              ; 계산된 화면 Y 어드레스를 DI 레지스터에 설정

    ; X 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함
    mov ax, word [ bp + 4 ] ; 파라미터 1(X좌표)를 AX 레지스터에 설정
    mov si, 2               ; 한 문자를 나타내는 바이트수(2)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 X 어드레스를 계산
    add di, ax              ; 화면 Y 어드레스와 계산된 X 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

    ; 출력할 문자열의 어드레스
    mov si, word [ bp + 8 ] ; 파라미터 3(출력할 문자열의 어드레스

.MESSAGELOOP:               ; 메시지를 출력하는 루프
    mov cl, byte [ si ]     ; SI 레지스터가 가리키는 문자열 위치에서 한 문자를 CL 레지스터에 복사
                            ; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
                            ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용

    cmp cl, 0               ; 복사된 문자와 0을 비교
    je  .MESSAGEEND         ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

    mov byte [ es: di ], cl ; 0이 아니라면 메모리 어드레스 0xB800:di에 문자를 출력

    add si, 1               ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2               ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동
                            ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함

    jmp .MESSAGELOOP        ; 메시지 출력 루프로 이동하여 다음 문자를 출력

.MESSAGEEND:
    pop dx      ; 함수에서 사용이 끝난 DX 레지스터부터 ES 레지스터까지를 스택에 삽입된 값을 이용해서 복원
    pop cx      ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다
    pop ax
    pop di
    pop si
    pop es
    pop bp      ; 베이트 포인터 레지스터(BP) 복원
    ret         ; 함수를 호출한 다음 코드의 위치로 복귀


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 부트로더 시작 메시지
MESSAGE1:   db 'MINT64 OS Boot Loader Start~!!', 0  ; 출력할 메시지 정의
                                                    ; 마지막은 0으로 설정하여 .MESSAGELOOP에서 처리할 수 있게 함
DISKERRORMESSAGE:       db  'DISK Error~!!', 0
IMAGELOADINGMESSAGE:    db  'OS Image Loading...', 0
LOADINGCOMPLETEMESSAGE: db  'Complete~!!', 0

; 디스크 읽기 관련된 변수들
SECTORNUMBER:       db  0x02    ; OS 이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER:         db  0x00    ; OS 이미지가 시작하는 헤드 번호를 저장하는 영역
TRACKNUMBER:        db  0x00    ; OS 이미지가 시작하는 트랙 번호를 저장하는 영역

times 510 - ( $ - $$ )  db  0x00    ; $: 현재 라인의 어드레스
                                    ; $$: 현재 섹션(.text)의 시작 어드레스
                                    ; $ - $$: 현재 섹션을 기준으로 하는 오프셋
                                    ; 510 - ( $ - $$ ): 현재부터 어드레스 510까지
                                    ; db 0x00: 1바이트를 선언하고 값은 0x00
                                    ; time: 반복 수행
                                    ; 현재 위치에서 어드레스 510까지 0x00으로 채움

db 0x55             ; 1바이트를 선언하고 값은 0x55
db 0xAA             ; 1바이트를 선언하고 값은 0xAA
```

추가되거나 변경된 소스가 많이 있으니 한줄한줄 비교해가면서 소스 수정해보기를 권한다.
실행하면 이런 화면이 나온다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img6.png)

부트로더는 완성했지만 로딩할 커널 이미지가 없기 때문이다.
이제부터 테스트에 사용할 가상 OS 이미지를 만들어보겠다.


### 테스트를 위한 가상 OS 이미지 생성
가상 OS 이미지는 여기서만 사용하고 후에 실제 OS 이미지로 대체하므로 세세한 부분까지 구현하지 않아도 무관하다.
부트로더 코드를 기반으로 기능을 간소화하여 OS가 실행되었음을 표시하는 기능만 넣겠다.
자신의 섹터 번호를 화면 위치에 대응시켜서 0~9까지 번호를 출력한다면 화면에 출력된 문자의 위치와 수를 확인하여 정상여부를 판단할 수 있다.
아래 그림은 가상 OS를 사용한 부트로더 테스트 과정을 순서대로 정리한 것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img7.jpg)

비록 가상 OS의 기능은 단순하지만, 가상 OS 이미지의 크기는 적어도 수백 KB 정도는 되어야 한다.
왜냐하면 최종 MINT64 OS 이미지가 수백 KB로 구성도기 때문이다.
가상 OS 이미지는 이러한 상황을 고려하여 충분한 크기인 512 KB(1024섹터)크기로 정했다.
1024섹터나 되는 코드를 작성해야하나?
섹터마다 화면 출력코드와 다음 섹터로 이동하는 코드르 넣어야하는데, 다행히 NASM은 뛰어난 전처리기(Preprocessor)를 제공하므로 이러한 작업을 간단하게 처리할 수 있다.
NASM 전처리기는 매크로(Macro), 조건(Condition), 반복(Loop) 구문을 지원하며, 변수 할당과 값 지정도 가능하다.
이러한 구문을 활용하면 숫자를 변경하는 것만으로 가상 OS 이미지의 크기를 변경할 수 있다.

가상 OS 이미지는 거의 같은 코드가 반복되는 구조이므로 우선 첫 번째 섹터에 삽입할 코드를 구현하고 나서 이를 반복하여 나머지 섹터를 생성하겠다.
먼저 01.Kernel32 디렉터리에 가상 OS소스 파일로 사용할 [VirtualOS.asm](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/MINT64/01.Kernel32/VirtualOS.asm) 파일을 생성하겠다.
파일 생성이 완료되면 아래의 코드를 입력한다.
부트 로더 코드와 동일한 방시그올 레지스터 초기화를 수행한 뒤 화면 2번째 라인의 가장 왼쪽 위치에 0을 출력하도록 했다.
SECTORCOUNT라는 메로리 어드레스는 정상적으로 처리된 섹터의 수를 기록하고, 이를 사용해 화면에 출력될 자표를 계산할 용도로 추가했다.
지금은 한 섹터 크기의 코드이므로 이 값이 중요한 역할을 하지는 않는다.
가상 OS 소스 코드 부트 로더 코드와 거의 같으므로 크게 어려운 부분을 없을것이다.

``` asm
[ORG 0x00]          ; 코드의 시작 어드레스르  0x00으로 설정
[BITS 16]           ; 아래의 코드는 16비트 코드로 설정

SECTION .text       ; text 섹션(세그먼트)을 정의

jmp 0x1000:START    ; CS 세그먼트 레지스터에 0x1000을 복사하면서, START 레이블로 이동

SECTORCOUNT:    dw 0x0000   ; 현재 실행중인 섹터 번호를 저장

START:
    mov ax, cs                  ; CS 레지스터의 값을 AX 레지스터에 설정
    mov ds, ax                  ; AX 레지스터의 값을 DS 세그먼트 레지스터에 설정
    mov ax, 0xB800              ; 비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터 값으로 변환
    mov es, ax                  ; ES 세그먼트 레지스터에 설정
    
    mov ax, 2                   ; 한 문자를 나타내는 바이트 수(2)를 AX 레지스터에 설정 
    mul word [ SECTORCOUNT ]    ; AX 레지스터와 섹터 수를 곱함
    mov si, ax                  ; 곱한 결과를 SI 레지스터에 설정
    mov byte [ es: si + ( 160 * 2 ) ], '0'  ; 계산된 결과를 비디오 메모리에 오프셋으로 삼아 세 번째 라인부터 화면에 0을 출력
    add word [ SECTORCOUNT ], 1             ; 섹터 수를 1 증가
    
    jmp $                       ; 현재 위치에서 무한루프 수행
    
    times 512 - ( $ - $$ )  db  0x00    ; $: 현재 라인의 어드레스
                                        ; $$: 현재 섹션(.text)의 시작 어드레스
                                        ; $ - $$: 현재 섹션을 기준으로 하는 오프셋
                                        ; 510 - ( $ - $$ ): 현재부터 어드레스 512까지
                                        ; db 0x00: 1바이트를 선언하고 값은 0x00
                                        ; time: 반복 수행
                                        ; 현재 위치에서 어드레스 512까지 0x00으로 채움
```

이제는 1섹터 크기의 가상 OS 코드를 확장해서 1024 섹터로 만들어 보겠다.
1024섹터의 가상 OS 이미지를 만든 방법은 의외로 간단하다.
1024 섹터중에 마니작 섹터를 제외한 1023섹터의 코드를 화면에 자신을 출력하는 코드 및 다음 섹터의 어드레스로 이동하는 코드를 반복하면 된다.
그리고 마지막 섹터 하나는 더이상 섹터가 없으므로 위 예제와 같이 자신을 출력하고 무한 루프를 수행하도록 하면 끝이다.

거의 같은 코드가 반복되므로 매크로 같은 전처리문을 이용하면 쉽게 처리할 수 잇다.
NASM 어셈블러는 이처럼 반복되는 구문을 위해 `%rep`라는 전처리문을 제공한다.
사용 방법은 times와 동일하게 반복 횟수와 반복할 대상을 입력하면 되며, `%endrep` 사이의 코드를 반복 횟수만큼 확장해준다.
이뿐만 아니라 변수 할당과 대입문(`$assign`), 조건문(`%if %elif %else %endif`)도 지원하므로 이것을 사용하면 아주 쉽게 코드를 확장할 수 있다.
전처리문이 적용된 소스코드는 아래와 같다.
`TOTALSECTORCOUNT`라는 상수를 1024로 정의하여 1024섹터의 OS 이미지가 생성되도록 구현했다.
참고로 `equ` 명령은 상수를 정의하는 명령이다.

``` asm
[ORG 0x00]          ; 코드의 시작 어드레스르  0x00으로 설정
[BITS 16]           ; 아래의 코드는 16비트 코드로 설정

SECTION .text       ; text 섹션(세그먼트)을 정의

jmp 0x1000:START    ; CS 세그먼트 레지스터에 0x1000을 복사하면서, START 레이블로 이동

SECTORCOUNT:        dw 0x0000   ; 현재 실행중인 섹터 번호를 저장
TOTALSECTORCOUNT:   equ 1024    ; 가상 OS의 총 섹터 수, 최대 1152섹터(0x90000byte)까지 가능


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

START:
    mov ax, cs                  ; CS 레지스터의 값을 AX 레지스터에 설정
    mov ds, ax                  ; AX 레지스터의 값을 DS 세그먼트 레지스터에 설정
    mov ax, 0xB800              ; 비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터 값으로 변환
    mov es, ax                  ; ES 세그먼트 레지스터에 설정


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 각 섹터  별로 코드를 생성
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    %assign i 0                 ; i라는 변수를 지정하고 0으로 초기화
    %rep TOTALSECTORCOUNT       ; TOTALSECTORCOUNT에 저장된 값 만큼 아래 코드를 반복
        $assign i i + 1         ; i를 1증가

        ; 현재 실행 중인 코드가 포함된 섹터의 위치를 화면 좌표로 변환
        mov ax, 2                   ; 한 문자를 나타내는 바이트 수(2)를 AX 레지스터에 설정
        mul word [ SECTORCOUNT ]    ; AX 레지스터와 섹터 수를 곱함
        mov si, ax                  ; 곱한 결과를 SI 레지스터에 설정

        ; 계산된 결과를 비디오 메모리에 오프셋으로 삼아 세 번째 라인부터 화면에 0을 출력
        mov byte [ es: si + ( 160 * 2 ) ], '0' + ( i % 10 )
        add word [ SECTORCOUNT ], 1             ; 섹터 수를 1 증가

        ; 마지막 섹터이면 더 수행할 섹터가 없으므로 무한 루프 실행 그렇지 않으면 다음 섹터로 이동해서 코드 수행
        %if i == TOTALSECTORCOUNT       ; i가 TOTALSECTORCOUNT와 같다면(마지막 섹터라면)
            jmp $                       ; 현재위치에서 무한 루프 수행
        %else
            jmp  ( 0x1000 + i * 0x20 ): 0x0000  ; 다음 섹터 오프셋으로 이동
        %endif                          ; if 문의 끝

        times ( 512 - ( $ - $$ ) % 512 )  db  0x00  ; $: 현재 라인의 어드레스
                                                    ; $$: 현재 섹션(.text)의 시작 어드레스
                                                    ; $ - $$: 현재 섹션을 기준으로 하는 오프셋
                                                    ; 512 - ( $ - $$ ): %512 현재부터 어드레스 512까지
                                                    ; db 0x00: 1바이트를 선언하고 값은 0x00
                                                    ; time: 반복 수행
                                                    ; 현재 위치에서 어드레스 512까지 0x00으로 채움
    %endrep     ; 반복문의 끝
```

가상 OS 소스코드가 완성되었다.
소스 코드는 이미지 파일로 생성되지 않으면 의미가 없으므로, makefile을 01.Kernel32 디렉터리에 추가하여 부트 로더와 동시에 빌드되도록 하겠다.
가상 OS 이미지는 부트 로더와 같은 구조를 하고 있으므로 부트 로더용 makefile을 복사하여 사용하면 반복 작업을 줄일 수 있다.
00.BootLoader  디렉터리의 makefile을 01.Kernel 디렉터리로 복사한다음 아래와 같이 수정한다.

``` makefile
all: VirtualOS.bin

VirtualOS.bin: VirtualOS.asm
	nasm -o VirtualOS.bin VirtualOS.asm

clean:
	rm -f VirtualOS.bin
```

### OS 이미지 통합과 QEMU 실행
가상 OS 이미지까지 준비되었으므로, 이제 파일들을 하나로 합쳐서 부팅 이미지를 만드는 작업만 남았다.
부팅 이미지를 만드는 작업은 최상위 디렉터리에 있는 makefile이 담당하고 있다.
최상위 디렉터리의 makefile은 4장에서 이미 생성했으므로, 가상 OS에 관련된 부분만 추가하여 테스틀하겠다.
우선 부트 로더와 같은 방법으로 01.Kernel 디렉터리에서 make를 수행하여 가상 OS 이미지를 빌드한다.
그리고 부트 이미지를 복사해서 부티 ㅇ이미지를 만드는 기존 방식을 수정하여 부트로더와 가상 OS 이미지를 하나의 파일로 합치도록 수정한다.
두 파일을 하나로 합치려면 파일을 내용을 표시하는 cat 프로그램을 사용하면된다.
cat을 사용하면 `cat A B C > D`와 같으 ㄴ방식으로 A, B, C파일을 하나로 합쳐 D 파일로 만들 수 있다.
아래 코드는 수정한 makefile이다.
all 레이블에 `BootLoader Kernel32 Disk.img`를 ㅣㅇㅂ력해서 부트로더 -> 가상 OS 이미지 -> 부팅 이미지 순서로 진행한다.

``` makefile
all: BootLoader Kernel32 Disk.img

BootLoader:
	@echo
	@echo =============== Build Boot Loader ===============
	@echo

	make -C 00.BootLoader

	@echo
	@echo =============== Build Complete ===============
	@echo

Kernel32:
	@echo
	@echo =============== Build 32bit Kernel ===============
	@echo

	make -C 01.Kernel32

	@echo
	@echo =============== Build Complete ===============
	@echo

Disk.img: BootLoader Kernel32
	@echo
	@echo =============== Disk Image Build Start ===============
	@echo

	cat 00.BootLoader/BootLoader.bin 01.Kernel32/VirtualOS.bin  > Disk.img

	@echo
	@echo =============== All Build Complete ===============
	@echo

clean:
	make -C 00.BootLoader clean
	make -C 01.Kernel32 clean
	rm -f Disk.img
```

그러면 `make`명령으로 빌드해보자

```
> make

=============== Build Boot Loader ===============

make -C 00.BootLoader
make[1]: Nothing to be done for `all'.

=============== Build Complete ===============


=============== Build 32bit Kernel ===============

make -C 01.Kernel32
make[1]: Nothing to be done for `all'.

=============== Build Complete ===============


=============== Disk Image Build Start ===============

cat 00.BootLoader/BootLoader.bin 01.Kernel32/VirtualOS.bin  > Disk.img

=============== All Build Complete ===============

```

실행하면 이런 화면을 볼 수 있다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch5_img8.png)

다음장인 6장에서는 OS의 핵심 역할을 하는 커널에 대하 공부할것이다.
커널이 추가되면 지금까지의 리얼모드에서 벗어나서 32비트 보호모드, 64비트의 IA-32e모드로 전환하고 멀티태스킹 같은 고급 기능이 추가되기 때문에 차츰 OS의 모습을 갖추게 된다.
6장에서는 첫 단계인 보호모드로 전환하는 과정을 공부할 것이다.
